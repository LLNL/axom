! wrapfquest.F
! This file is generated by Shroud 0.13.0. Do not edit.
!
! Copyright (c) 2017-2024, Lawrence Livermore National Security, LLC and
! other Axom Project Developers. See the top-level LICENSE file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!>
!! \file wrapfquest.F
!! \brief Shroud generated wrapper for quest namespace
!<
! splicer begin file_top
#include <axom/config.hpp>
! splicer end file_top
module axom_quest
    use iso_c_binding, only : C_INT
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    !  enum class axom::quest::SignedDistExec
    integer(C_INT), parameter :: signeddistexec_cpu = 0
    integer(C_INT), parameter :: signeddistexec_openmp = 1
    integer(C_INT), parameter :: signeddistexec_gpu = 2

    interface

#ifdef AXOM_USE_MPI
        function c_inout_init_mpi(fileName, comm) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_init_mpi")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: fileName(*)
            integer(C_INT), value, intent(IN) :: comm
            integer(C_INT) :: SHT_rv
        end function c_inout_init_mpi
#endif

#ifdef AXOM_USE_MPI
        function c_inout_init_mpi_bufferify(fileName, SHT_fileName_len, &
                comm) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_init_mpi_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: fileName(*)
            integer(C_INT), value, intent(IN) :: SHT_fileName_len
            integer(C_INT), value, intent(IN) :: comm
            integer(C_INT) :: SHT_rv
        end function c_inout_init_mpi_bufferify
#endif

#ifndef AXOM_USE_MPI
        function c_inout_init_serial(fileName) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_init_serial")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: fileName(*)
            integer(C_INT) :: SHT_rv
        end function c_inout_init_serial
#endif

#ifndef AXOM_USE_MPI
        function c_inout_init_serial_bufferify(fileName, &
                SHT_fileName_len) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_init_serial_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: fileName(*)
            integer(C_INT), value, intent(IN) :: SHT_fileName_len
            integer(C_INT) :: SHT_rv
        end function c_inout_init_serial_bufferify
#endif

        function c_inout_initialized() &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_initialized")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL) :: SHT_rv
        end function c_inout_initialized

        function quest_inout_set_dimension(dim) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_set_dimension")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: dim
            integer(C_INT) :: SHT_rv
        end function quest_inout_set_dimension

        function c_inout_set_verbose(verbosity) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_set_verbose")
            use iso_c_binding, only : C_BOOL, C_INT
            implicit none
            logical(C_BOOL), value, intent(IN) :: verbosity
            integer(C_INT) :: SHT_rv
        end function c_inout_set_verbose

        function quest_inout_set_vertex_weld_threshold(thresh) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_set_vertex_weld_threshold")
            use iso_c_binding, only : C_DOUBLE, C_INT
            implicit none
            real(C_DOUBLE), value, intent(IN) :: thresh
            integer(C_INT) :: SHT_rv
        end function quest_inout_set_vertex_weld_threshold

        function quest_inout_set_segments_per_knot_span( &
                segmentsPerKnotSpan) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_set_segments_per_knot_span")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: segmentsPerKnotSpan
            integer(C_INT) :: SHT_rv
        end function quest_inout_set_segments_per_knot_span

        function c_inout_evaluate_0(x, y) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_evaluate_0")
            use iso_c_binding, only : C_BOOL, C_DOUBLE
            implicit none
            real(C_DOUBLE), value, intent(IN) :: x
            real(C_DOUBLE), value, intent(IN) :: y
            logical(C_BOOL) :: SHT_rv
        end function c_inout_evaluate_0

        function c_inout_evaluate_1(x, y, z) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_evaluate_1")
            use iso_c_binding, only : C_BOOL, C_DOUBLE
            implicit none
            real(C_DOUBLE), value, intent(IN) :: x
            real(C_DOUBLE), value, intent(IN) :: y
            real(C_DOUBLE), value, intent(IN) :: z
            logical(C_BOOL) :: SHT_rv
        end function c_inout_evaluate_1

        function quest_inout_mesh_min_bounds(coords) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_mesh_min_bounds")
            use iso_c_binding, only : C_DOUBLE, C_INT
            implicit none
            real(C_DOUBLE), intent(OUT) :: coords(*)
            integer(C_INT) :: SHT_rv
        end function quest_inout_mesh_min_bounds

        function quest_inout_mesh_max_bounds(coords) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_mesh_max_bounds")
            use iso_c_binding, only : C_DOUBLE, C_INT
            implicit none
            real(C_DOUBLE), intent(OUT) :: coords(*)
            integer(C_INT) :: SHT_rv
        end function quest_inout_mesh_max_bounds

        function quest_inout_mesh_center_of_mass(coords) &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_mesh_center_of_mass")
            use iso_c_binding, only : C_DOUBLE, C_INT
            implicit none
            real(C_DOUBLE), intent(OUT) :: coords(*)
            integer(C_INT) :: SHT_rv
        end function quest_inout_mesh_center_of_mass

        function quest_inout_get_dimension() &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_get_dimension")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT) :: SHT_rv
        end function quest_inout_get_dimension

        function quest_inout_finalize() &
                result(SHT_rv) &
                bind(C, name="QUEST_inout_finalize")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT) :: SHT_rv
        end function quest_inout_finalize

#ifdef AXOM_USE_MPI
        function c_signed_distance_init_mpi(file, comm) &
                result(SHT_rv) &
                bind(C, name="QUEST_signed_distance_init_mpi")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: file(*)
            integer(C_INT), value, intent(IN) :: comm
            integer(C_INT) :: SHT_rv
        end function c_signed_distance_init_mpi
#endif

#ifdef AXOM_USE_MPI
        function c_signed_distance_init_mpi_bufferify(file, &
                SHT_file_len, comm) &
                result(SHT_rv) &
                bind(C, name="QUEST_signed_distance_init_mpi_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: file(*)
            integer(C_INT), value, intent(IN) :: SHT_file_len
            integer(C_INT), value, intent(IN) :: comm
            integer(C_INT) :: SHT_rv
        end function c_signed_distance_init_mpi_bufferify
#endif

#ifndef AXOM_USE_MPI
        function c_signed_distance_init_serial(file) &
                result(SHT_rv) &
                bind(C, name="QUEST_signed_distance_init_serial")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: file(*)
            integer(C_INT) :: SHT_rv
        end function c_signed_distance_init_serial
#endif

#ifndef AXOM_USE_MPI
        function c_signed_distance_init_serial_bufferify(file, &
                SHT_file_len) &
                result(SHT_rv) &
                bind(C, name="QUEST_signed_distance_init_serial_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: file(*)
            integer(C_INT), value, intent(IN) :: SHT_file_len
            integer(C_INT) :: SHT_rv
        end function c_signed_distance_init_serial_bufferify
#endif

        function c_signed_distance_initialized() &
                result(SHT_rv) &
                bind(C, name="QUEST_signed_distance_initialized")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL) :: SHT_rv
        end function c_signed_distance_initialized

        subroutine quest_signed_distance_get_mesh_bounds(lo, hi) &
                bind(C, name="QUEST_signed_distance_get_mesh_bounds")
            use iso_c_binding, only : C_DOUBLE
            implicit none
            real(C_DOUBLE), intent(OUT) :: lo(*)
            real(C_DOUBLE), intent(OUT) :: hi(*)
        end subroutine quest_signed_distance_get_mesh_bounds

        subroutine quest_signed_distance_set_dimension(dim) &
                bind(C, name="QUEST_signed_distance_set_dimension")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: dim
        end subroutine quest_signed_distance_set_dimension

        subroutine c_signed_distance_set_closed_surface(status) &
                bind(C, name="QUEST_signed_distance_set_closed_surface")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL), value, intent(IN) :: status
        end subroutine c_signed_distance_set_closed_surface

        subroutine c_signed_distance_set_compute_signs(computeSign) &
                bind(C, name="QUEST_signed_distance_set_compute_signs")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL), value, intent(IN) :: computeSign
        end subroutine c_signed_distance_set_compute_signs

        subroutine quest_signed_distance_set_allocator(allocatorID) &
                bind(C, name="QUEST_signed_distance_set_allocator")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: allocatorID
        end subroutine quest_signed_distance_set_allocator

        subroutine c_signed_distance_set_verbose(status) &
                bind(C, name="QUEST_signed_distance_set_verbose")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL), value, intent(IN) :: status
        end subroutine c_signed_distance_set_verbose

        subroutine c_signed_distance_use_shared_memory(status) &
                bind(C, name="QUEST_signed_distance_use_shared_memory")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL), value, intent(IN) :: status
        end subroutine c_signed_distance_use_shared_memory

        subroutine quest_signed_distance_set_execution_space(execSpace) &
                bind(C, name="QUEST_signed_distance_set_execution_space")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: execSpace
        end subroutine quest_signed_distance_set_execution_space

        function c_signed_distance_evaluate_0(x, y, z) &
                result(SHT_rv) &
                bind(C, name="QUEST_signed_distance_evaluate_0")
            use iso_c_binding, only : C_DOUBLE
            implicit none
            real(C_DOUBLE), value, intent(IN) :: x
            real(C_DOUBLE), value, intent(IN) :: y
            real(C_DOUBLE), value, intent(IN) :: z
            real(C_DOUBLE) :: SHT_rv
        end function c_signed_distance_evaluate_0

        function c_signed_distance_evaluate_1(x, y, z, cp_x, cp_y, cp_z, &
                n_x, n_y, n_z) &
                result(SHT_rv) &
                bind(C, name="QUEST_signed_distance_evaluate_1")
            use iso_c_binding, only : C_DOUBLE
            implicit none
            real(C_DOUBLE), value, intent(IN) :: x
            real(C_DOUBLE), value, intent(IN) :: y
            real(C_DOUBLE), value, intent(IN) :: z
            real(C_DOUBLE), intent(INOUT) :: cp_x
            real(C_DOUBLE), intent(INOUT) :: cp_y
            real(C_DOUBLE), intent(INOUT) :: cp_z
            real(C_DOUBLE), intent(INOUT) :: n_x
            real(C_DOUBLE), intent(INOUT) :: n_y
            real(C_DOUBLE), intent(INOUT) :: n_z
            real(C_DOUBLE) :: SHT_rv
        end function c_signed_distance_evaluate_1

        subroutine quest_signed_distance_finalize() &
                bind(C, name="QUEST_signed_distance_finalize")
            implicit none
        end subroutine quest_signed_distance_finalize
    end interface

    interface quest_inout_evaluate
        module procedure quest_inout_evaluate_0
        module procedure quest_inout_evaluate_1
    end interface quest_inout_evaluate

    interface quest_inout_init
#ifdef AXOM_USE_MPI
        module procedure quest_inout_init_mpi
#endif
#ifndef AXOM_USE_MPI
        module procedure quest_inout_init_serial
#endif
    end interface quest_inout_init

    interface quest_signed_distance_evaluate
        module procedure quest_signed_distance_evaluate_0
        module procedure quest_signed_distance_evaluate_1
    end interface quest_signed_distance_evaluate

    interface quest_signed_distance_init
#ifdef AXOM_USE_MPI
        module procedure quest_signed_distance_init_mpi
#endif
#ifndef AXOM_USE_MPI
        module procedure quest_signed_distance_init_serial
#endif
    end interface quest_signed_distance_init

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

#ifdef AXOM_USE_MPI
    function quest_inout_init_mpi(fileName, comm) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: fileName
        integer, value, intent(IN) :: comm
        integer(C_INT) :: SHT_rv
        ! splicer begin function.inout_init_mpi
        integer(C_INT) SHT_fileName_len
        SHT_fileName_len = len(fileName, kind=C_INT)
        SHT_rv = c_inout_init_mpi_bufferify(fileName, SHT_fileName_len, &
            comm)
        ! splicer end function.inout_init_mpi
    end function quest_inout_init_mpi
#endif

#ifndef AXOM_USE_MPI
    function quest_inout_init_serial(fileName) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: fileName
        integer(C_INT) :: SHT_rv
        ! splicer begin function.inout_init_serial
        integer(C_INT) SHT_fileName_len
        SHT_fileName_len = len(fileName, kind=C_INT)
        SHT_rv = c_inout_init_serial_bufferify(fileName, &
            SHT_fileName_len)
        ! splicer end function.inout_init_serial
    end function quest_inout_init_serial
#endif

    function quest_inout_initialized() &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL
        logical :: SHT_rv
        ! splicer begin function.inout_initialized
        SHT_rv = c_inout_initialized()
        ! splicer end function.inout_initialized
    end function quest_inout_initialized

    function quest_inout_set_verbose(verbosity) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_INT
        logical, value, intent(IN) :: verbosity
        integer(C_INT) :: SHT_rv
        ! splicer begin function.inout_set_verbose
        logical(C_BOOL) SH_verbosity
        SH_verbosity = verbosity  ! coerce to C_BOOL
        SHT_rv = c_inout_set_verbose(SH_verbosity)
        ! splicer end function.inout_set_verbose
    end function quest_inout_set_verbose

    function quest_inout_evaluate_0(x, y) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE
        real(C_DOUBLE), value, intent(IN) :: x
        real(C_DOUBLE), value, intent(IN) :: y
        logical :: SHT_rv
        ! splicer begin function.inout_evaluate_0
        SHT_rv = c_inout_evaluate_0(x, y)
        ! splicer end function.inout_evaluate_0
    end function quest_inout_evaluate_0

    function quest_inout_evaluate_1(x, y, z) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE
        real(C_DOUBLE), value, intent(IN) :: x
        real(C_DOUBLE), value, intent(IN) :: y
        real(C_DOUBLE), value, intent(IN) :: z
        logical :: SHT_rv
        ! splicer begin function.inout_evaluate_1
        SHT_rv = c_inout_evaluate_1(x, y, z)
        ! splicer end function.inout_evaluate_1
    end function quest_inout_evaluate_1

#ifdef AXOM_USE_MPI
    function quest_signed_distance_init_mpi(file, comm) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: file
        integer, value, intent(IN) :: comm
        integer(C_INT) :: SHT_rv
        ! splicer begin function.signed_distance_init_mpi
        integer(C_INT) SHT_file_len
        SHT_file_len = len(file, kind=C_INT)
        SHT_rv = c_signed_distance_init_mpi_bufferify(file, &
            SHT_file_len, comm)
        ! splicer end function.signed_distance_init_mpi
    end function quest_signed_distance_init_mpi
#endif

#ifndef AXOM_USE_MPI
    function quest_signed_distance_init_serial(file) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: file
        integer(C_INT) :: SHT_rv
        ! splicer begin function.signed_distance_init_serial
        integer(C_INT) SHT_file_len
        SHT_file_len = len(file, kind=C_INT)
        SHT_rv = c_signed_distance_init_serial_bufferify(file, &
            SHT_file_len)
        ! splicer end function.signed_distance_init_serial
    end function quest_signed_distance_init_serial
#endif

    function quest_signed_distance_initialized() &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL
        logical :: SHT_rv
        ! splicer begin function.signed_distance_initialized
        SHT_rv = c_signed_distance_initialized()
        ! splicer end function.signed_distance_initialized
    end function quest_signed_distance_initialized

    subroutine quest_signed_distance_set_closed_surface(status)
        use iso_c_binding, only : C_BOOL
        logical, value, intent(IN) :: status
        ! splicer begin function.signed_distance_set_closed_surface
        logical(C_BOOL) SH_status
        SH_status = status  ! coerce to C_BOOL
        call c_signed_distance_set_closed_surface(SH_status)
        ! splicer end function.signed_distance_set_closed_surface
    end subroutine quest_signed_distance_set_closed_surface

    subroutine quest_signed_distance_set_compute_signs(computeSign)
        use iso_c_binding, only : C_BOOL
        logical, value, intent(IN) :: computeSign
        ! splicer begin function.signed_distance_set_compute_signs
        logical(C_BOOL) SH_computeSign
        SH_computeSign = computeSign  ! coerce to C_BOOL
        call c_signed_distance_set_compute_signs(SH_computeSign)
        ! splicer end function.signed_distance_set_compute_signs
    end subroutine quest_signed_distance_set_compute_signs

    subroutine quest_signed_distance_set_verbose(status)
        use iso_c_binding, only : C_BOOL
        logical, value, intent(IN) :: status
        ! splicer begin function.signed_distance_set_verbose
        logical(C_BOOL) SH_status
        SH_status = status  ! coerce to C_BOOL
        call c_signed_distance_set_verbose(SH_status)
        ! splicer end function.signed_distance_set_verbose
    end subroutine quest_signed_distance_set_verbose

    subroutine quest_signed_distance_use_shared_memory(status)
        use iso_c_binding, only : C_BOOL
        logical, value, intent(IN) :: status
        ! splicer begin function.signed_distance_use_shared_memory
        logical(C_BOOL) SH_status
        SH_status = status  ! coerce to C_BOOL
        call c_signed_distance_use_shared_memory(SH_status)
        ! splicer end function.signed_distance_use_shared_memory
    end subroutine quest_signed_distance_use_shared_memory

    function quest_signed_distance_evaluate_0(x, y, z) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        real(C_DOUBLE), value, intent(IN) :: x
        real(C_DOUBLE), value, intent(IN) :: y
        real(C_DOUBLE), value, intent(IN) :: z
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin function.signed_distance_evaluate_0
        SHT_rv = c_signed_distance_evaluate_0(x, y, z)
        ! splicer end function.signed_distance_evaluate_0
    end function quest_signed_distance_evaluate_0

    function quest_signed_distance_evaluate_1(x, y, z, cp_x, cp_y, cp_z, &
            n_x, n_y, n_z) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        real(C_DOUBLE), value, intent(IN) :: x
        real(C_DOUBLE), value, intent(IN) :: y
        real(C_DOUBLE), value, intent(IN) :: z
        real(C_DOUBLE), intent(INOUT) :: cp_x
        real(C_DOUBLE), intent(INOUT) :: cp_y
        real(C_DOUBLE), intent(INOUT) :: cp_z
        real(C_DOUBLE), intent(INOUT) :: n_x
        real(C_DOUBLE), intent(INOUT) :: n_y
        real(C_DOUBLE), intent(INOUT) :: n_z
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin function.signed_distance_evaluate_1
        SHT_rv = c_signed_distance_evaluate_1(x, y, z, cp_x, cp_y, cp_z, &
            n_x, n_y, n_z)
        ! splicer end function.signed_distance_evaluate_1
    end function quest_signed_distance_evaluate_1

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module axom_quest
