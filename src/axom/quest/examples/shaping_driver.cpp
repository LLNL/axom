// Copyright (c) 2017-2023, Lawrence Livermore National Security, LLC and
// other Axom Project Developers. See the top-level COPYRIGHT file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)

/*!
 * \file shaping_driver.cpp
 * \brief Driver application for shaping material volume fractions onto a simulation mesh
 */

// Axom includes
#include "axom/config.hpp"
#include "axom/core.hpp"
#include "axom/slic.hpp"
#include "axom/primal.hpp"
#include "axom/sidre.hpp"
#include "axom/klee.hpp"
#include "axom/quest.hpp"

#include "axom/fmt.hpp"
#include "axom/CLI11.hpp"

// NOTE: The shaping driver requires Axom to be configured with mfem as well as
// the AXOM_ENABLE_MFEM_SIDRE_DATACOLLECTION CMake option
#ifndef AXOM_USE_MFEM
  #error Shaping functionality requires Axom to be configured with MFEM and the AXOM_ENABLE_MFEM_SIDRE_DATACOLLECTION option
#endif

#include "mfem.hpp"

#ifdef AXOM_USE_MPI
  #include "mpi.h"
#endif

// RAJA
#ifdef AXOM_USE_RAJA
  #include "RAJA/RAJA.hpp"
#endif

// C/C++ includes
#include <string>
#include <vector>

namespace quest = axom::quest;
namespace slic = axom::slic;
namespace sidre = axom::sidre;
namespace klee = axom::klee;

using VolFracSampling = quest::shaping::VolFracSampling;

//------------------------------------------------------------------------------

/// Struct to help choose if our shaping method: sampling or intersection for now
enum class ShapingMethod : int
{
  Sampling,
  Intersection
};

/// Choose runtime policy for RAJA
enum RuntimePolicy
{
  seq = 0,
  omp = 1,
  cuda = 2,
  hip = 3
};

/// Struct to parse and store the input parameters
struct Input
{
public:
  std::string meshFile;

  std::string shapeFile;
  klee::ShapeSet shapeSet;

  ShapingMethod shapingMethod {ShapingMethod::Sampling};
  RuntimePolicy policy {seq};
  int quadratureOrder {5};
  int outputOrder {2};
  int samplesPerKnotSpan {25};
  int refinementLevel {7};
  double weldThresh {1e-9};

  VolFracSampling vfSampling {VolFracSampling::SAMPLE_AT_QPTS};

private:
  bool m_verboseOutput {false};

  // clang-format off
  const std::map<std::string, RuntimePolicy> s_validPolicies{
    #if defined(AXOM_USE_RAJA) && defined(AXOM_USE_UMPIRE)
      {"seq", seq}
      #ifdef AXOM_USE_OPENMP
    , {"omp", omp}
      #endif
      #ifdef AXOM_USE_CUDA
    , {"cuda", cuda}
      #endif
      #ifdef AXOM_USE_HIP
    , {"hip", hip}
      #endif
    #endif
  };
  // clang-format on

public:
  bool isVerbose() const { return m_verboseOutput; }

  std::string getDCMeshName() const
  {
    using axom::utilities::string::removeSuffix;

    // Remove the parent directories and file suffix
    std::string name = axom::Path(meshFile).baseName();
    name = removeSuffix(name, ".root");

    return name;
  }

  void parse(int argc, char** argv, axom::CLI::App& app)
  {
    app.add_option("-m,--mesh-file", meshFile)
      ->description(
        "Path to computational mesh (generated by MFEMSidreDataCollection)")
      ->check(axom::CLI::ExistingFile)
      ->required();

    app.add_option("-i,--shape-file", shapeFile)
      ->description("Path to input shape file")
      ->check(axom::CLI::ExistingFile)
      ->required();

    app.add_flag("-v,--verbose,!--no-verbose", m_verboseOutput)
      ->description("Enable/disable verbose output")
      ->capture_default_str();

    app.add_option("-n,--segments-per-knot-span", samplesPerKnotSpan)
      ->description(
        "(2D only) Number of linear segments to generate per NURBS knot span")
      ->capture_default_str()
      ->check(axom::CLI::PositiveNumber);

    app.add_option("-t,--weld-threshold", weldThresh)
      ->description("Threshold for welding")
      ->check(axom::CLI::NonNegativeNumber)
      ->capture_default_str();

    // Parameter to determine if we're using a file or a box mesh
    std::map<std::string, ShapingMethod> methodMap {
      {"sampling", ShapingMethod::Sampling},
      {"intersection", ShapingMethod::Intersection}};
    app.add_option("--method", shapingMethod)
      ->description(
        "Determines the shaping method -- either sampling or intersection")
      ->capture_default_str()
      ->transform(
        axom::CLI::CheckedTransformer(methodMap, axom::CLI::ignore_case));

    // parameters that only apply to the sampling method
    auto* sampling_options =
      app.add_option_group("sampling",
                           "Options related to sampling-based queries");

    sampling_options->add_option("-o,--order", outputOrder)
      ->description("order of the output grid function")
      ->capture_default_str()
      ->check(axom::CLI::NonNegativeNumber);

    sampling_options->add_option("-q,--quadrature-order", quadratureOrder)
      ->description(
        "Quadrature order for sampling the inout field. \n"
        "Determines number of samples per element in determining "
        "volume fraction field")
      ->capture_default_str()
      ->check(axom::CLI::PositiveNumber);

    std::map<std::string, VolFracSampling> vfsamplingMap {
      {"qpts", VolFracSampling::SAMPLE_AT_QPTS},
      {"dofs", VolFracSampling::SAMPLE_AT_DOFS}};
    sampling_options->add_option("-s,--sampling-type", vfSampling)
      ->description(
        "Sampling strategy. \n"
        "Sampling either at quadrature points or collocated with "
        "degrees of freedom")
      ->capture_default_str()
      ->transform(
        axom::CLI::CheckedTransformer(vfsamplingMap, axom::CLI::ignore_case));

    // parameters that only apply to the intersection method
    auto* intersection_options =
      app.add_option_group("intersection",
                           "Options related to intersection-based queries");

    intersection_options->add_option("-r, --refinements", refinementLevel)
      ->description("Number of refinements to perform for revolved contour")
      ->capture_default_str()
      ->check(axom::CLI::NonNegativeNumber);

    std::stringstream pol_sstr;
    pol_sstr << "Set runtime policy for intersection-based sampling method.";
#if defined(AXOM_USE_RAJA) && defined(AXOM_USE_UMPIRE)
    pol_sstr << "\nSet to \'seq\' or 0 to use the RAJA sequential policy.";
  #ifdef AXOM_USE_OPENMP
    pol_sstr << "\nSet to \'omp\' or 1 to use the RAJA OpenMP policy.";
  #endif
  #ifdef AXOM_USE_CUDA
    pol_sstr << "\nSet to \'cuda\' or 2 to use the RAJA CUDA policy.";
  #endif
  #ifdef AXOM_USE_HIP
    pol_sstr << "\nSet to \'hip\' or 3 to use the RAJA HIP policy.";
  #endif
#endif

    intersection_options->add_option("-p, --policy", policy, pol_sstr.str())
      ->capture_default_str()
      ->transform(axom::CLI::CheckedTransformer(s_validPolicies));

    app.get_formatter()->column_width(50);

    // could throw an exception
    app.parse(argc, argv);

    slic::setLoggingMsgLevel(m_verboseOutput ? slic::message::Debug
                                             : slic::message::Info);
  }
};

/**
 * \brief Print some info about the mesh
 *
 * \note In MPI-based configurations, this is a collective call, but only prints on rank 0
 */
void printMeshInfo(mfem::Mesh* mesh, const std::string& prefixMessage = "")
{
  namespace primal = axom::primal;

  int myRank = 0;
#ifdef AXOM_USE_MPI
  MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
#endif

  int numElements = mesh->GetNE();

  mfem::Vector mins, maxs;
#ifdef MFEM_USE_MPI
  auto* pmesh = dynamic_cast<mfem::ParMesh*>(mesh);
  if(pmesh != nullptr)
  {
    pmesh->GetBoundingBox(mins, maxs);
    numElements = pmesh->ReduceInt(numElements);
    myRank = pmesh->GetMyRank();
  }
  else
#endif
  {
    mesh->GetBoundingBox(mins, maxs);
  }

  if(myRank == 0)
  {
    switch(mesh->Dimension())
    {
    case 2:
      SLIC_INFO(axom::fmt::format(
        "{} mesh has {} elements and (approximate) bounding box {}",
        prefixMessage,
        numElements,
        primal::BoundingBox<double, 2>(primal::Point<double, 2>(mins.GetData()),
                                       primal::Point<double, 2>(maxs.GetData()))));
      break;
    case 3:
      SLIC_INFO(axom::fmt::format(
        "{} mesh has {} elements and (approximate) bounding box {}",
        prefixMessage,
        numElements,
        primal::BoundingBox<double, 3>(primal::Point<double, 3>(mins.GetData()),
                                       primal::Point<double, 3>(maxs.GetData()))));
      break;
    }
  }

  slic::flushStreams();
}

/// \brief Utility function to initialize the logger
void initializeLogger()
{
  // Initialize Logger
  slic::initialize();
  slic::setLoggingMsgLevel(slic::message::Info);

  slic::LogStream* logStream {nullptr};

#ifdef AXOM_USE_MPI
  int num_ranks = 1;
  MPI_Comm_size(MPI_COMM_WORLD, &num_ranks);
  if(num_ranks > 1)
  {
    std::string fmt = "[<RANK>][<LEVEL>]: <MESSAGE>\n";
  #ifdef AXOM_USE_LUMBERJACK
    const int RLIMIT = 8;
    logStream =
      new slic::LumberjackStream(&std::cout, MPI_COMM_WORLD, RLIMIT, fmt);
  #else
    logStream = new slic::SynchronizedStream(&std::cout, MPI_COMM_WORLD, fmt);
  #endif
  }
  else
#endif  // AXOM_USE_MPI
  {
    std::string fmt = "[<LEVEL>]: <MESSAGE>\n";
    logStream = new slic::GenericOutputStream(&std::cout, fmt);
  }

  slic::addStreamToAllMsgLevels(logStream);
}

/// \brief Utility function to finalize the logger
void finalizeLogger()
{
  if(slic::isInitialized())
  {
    slic::flushStreams();
    slic::finalize();
  }
}

//------------------------------------------------------------------------------
int main(int argc, char** argv)
{
#ifdef AXOM_USE_MPI
  MPI_Init(&argc, &argv);
  int my_rank, num_ranks;
  MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &num_ranks);
#else
  int my_rank = 0;
  int num_ranks = 1;
#endif

  initializeLogger();

  //---------------------------------------------------------------------------
  // Set up and parse command line arguments
  //---------------------------------------------------------------------------
  Input params;
  axom::CLI::App app {"Driver for Klee shaping query"};

  try
  {
    params.parse(argc, argv, app);
  }
  catch(const axom::CLI::ParseError& e)
  {
    int retval = -1;
    if(my_rank == 0)
    {
      retval = app.exit(e);
    }
    finalizeLogger();

#ifdef AXOM_USE_MPI
    MPI_Bcast(&retval, 1, MPI_INT, 0, MPI_COMM_WORLD);
    MPI_Finalize();
#endif
    exit(retval);
  }

  //---------------------------------------------------------------------------
  // Load the klee shape file and extract some information
  //---------------------------------------------------------------------------
  try
  {
    params.shapeSet = klee::readShapeSet(params.shapeFile);
  }
  catch(klee::KleeError& error)
  {
    std::vector<std::string> errs;
    for(auto verificationError : error.getErrors())
    {
      errs.push_back(
        axom::fmt::format(" - '{}': {}",
                          static_cast<std::string>(verificationError.path),
                          verificationError.message));
    }

    SLIC_WARNING(axom::fmt::format(
      "Error during parsing klee input. Found the following errors:\n{}",
      axom::fmt::join(errs, "\n")));

    finalizeLogger();

#ifdef AXOM_USE_MPI
    MPI_Finalize();
#endif
    exit(1);
  }

  const klee::Dimensions shapeDim = params.shapeSet.getDimensions();

  // Apply error checking
#ifndef AXOM_USE_C2C
  SLIC_ERROR_IF(shapeDim == klee::Dimensions::Two,
                "Shaping with contour files requires an Axom configured with "
                "the C2C library");
#endif

  //---------------------------------------------------------------------------
  // Load the computational mesh
  //---------------------------------------------------------------------------
  const bool dc_owns_data = true;
  mfem::Mesh* originalMesh = nullptr;
  sidre::MFEMSidreDataCollection originalMeshDC(params.getDCMeshName(),
                                                originalMesh,
                                                dc_owns_data);
  {
    originalMeshDC.SetComm(MPI_COMM_WORLD);
    std::string protocol = "sidre_hdf5";
    originalMeshDC.Load(params.meshFile, protocol);
  }

  //---------------------------------------------------------------------------
  // Set up DataCollection for shaping
  //---------------------------------------------------------------------------
  mfem::Mesh* shapingMesh = nullptr;
  sidre::MFEMSidreDataCollection shapingDC("shaping", shapingMesh, dc_owns_data);
  {
    shapingDC.SetMeshNodesName("positions");

    auto* pmesh = dynamic_cast<mfem::ParMesh*>(originalMeshDC.GetMesh());
    shapingMesh = (pmesh != nullptr) ? new mfem::ParMesh(*pmesh)
                                     : new mfem::Mesh(*originalMeshDC.GetMesh());
    shapingDC.SetMesh(shapingMesh);
  }
  printMeshInfo(shapingDC.GetMesh(), "After loading");

  //---------------------------------------------------------------------------
  // Initialize the shaping query object
  //---------------------------------------------------------------------------
  quest::Shaper* shaper = nullptr;
  switch(params.shapingMethod)
  {
  case ShapingMethod::Sampling:
    shaper = new quest::SamplingShaper(params.shapeSet, &shapingDC);
    break;
  case ShapingMethod::Intersection:
    shaper = new quest::IntersectionShaper(params.shapeSet, &shapingDC);
    break;
  }
  SLIC_ASSERT_MSG(shaper != nullptr, "Invalid shaping method selected!");

  // Set generic parameters for the base Shaper instance
  shaper->setSamplesPerKnotSpan(params.samplesPerKnotSpan);
  shaper->setVertexWeldThreshold(params.weldThresh);
  shaper->setVerbosity(params.isVerbose());

  // Set specific parameters for a SamplingShaper, if appropriate
  if(auto* samplingShaper = dynamic_cast<quest::SamplingShaper*>(shaper))
  {
    samplingShaper->setSamplingType(params.vfSampling);
    samplingShaper->setQuadratureOrder(params.quadratureOrder);
    samplingShaper->setVolumeFractionOrder(params.outputOrder);
  }

  // Set specific parameters here for IntersectionShaper
  if(auto* intersectionShaper = dynamic_cast<quest::IntersectionShaper*>(shaper))
  {
    intersectionShaper->setLevel(params.refinementLevel);
    intersectionShaper->setExecPolicy(params.policy);
  }

  //---------------------------------------------------------------------------
  // Process each of the shapes
  //---------------------------------------------------------------------------
  SLIC_INFO(axom::fmt::format("{:=^80}", "Sampling InOut fields for shapes"));
  for(const auto& shape : params.shapeSet.getShapes())
  {
    // Load the shape from file
    shaper->loadShape(shape);
    slic::flushStreams();

    // Apply the specified geometric transforms
    shaper->applyTransforms(shape);
    slic::flushStreams();

    // Generate a spatial index over the shape
    shaper->prepareShapeQuery(shapeDim, shape);
    slic::flushStreams();

    // Query the mesh against this shape
    shaper->runShapeQuery(shape);
    slic::flushStreams();

    // Apply the replacement rules for this shape against the existing materials
    shaper->applyReplacementRules(shape);
    slic::flushStreams();

    // Finalize data structures associated with this shape and spatial index
    shaper->finalizeShapeQuery();
    slic::flushStreams();
  }

  //---------------------------------------------------------------------------
  // After shaping in all shapes, generate/adjust the material volume fractions
  //---------------------------------------------------------------------------
  SLIC_INFO(
    axom::fmt::format("{:=^80}",
                      "Generating volume fraction fields for materials"));

  shaper->adjustVolumeFractions();

  //---------------------------------------------------------------------------
  // Save meshes and fields
  //---------------------------------------------------------------------------
#ifdef MFEM_USE_MPI
  shaper->getDC()->Save();
#endif

  delete shaper;

  //---------------------------------------------------------------------------
  // Cleanup and exit
  //---------------------------------------------------------------------------
  finalizeLogger();
#ifdef AXOM_USE_MPI
  MPI_Finalize();
#endif

  return 0;
}
