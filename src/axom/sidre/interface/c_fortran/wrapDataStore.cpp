// wrapDataStore.cpp
// This file is generated by Shroud 0.13.0. Do not edit.
//
// Copyright (c) 2017-2024, Lawrence Livermore National Security, LLC and
// other Axom Project Developers. See the top-level LICENSE file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)

#include "axom/sidre/core/DataStore.hpp"
#include "axom/sidre/core/Group.hpp"
#include "axom/sidre/core/Buffer.hpp"
#include <string>
#include <cstddef>
#include "wrapDataStore.h"

// splicer begin class.DataStore.CXX_definitions
// splicer end class.DataStore.CXX_definitions

extern "C" {

// helper ShroudLenTrim
// Returns the length of character string src with length nsrc,
// ignoring any trailing blanks.
static int ShroudLenTrim(const char *src, int nsrc)
{
  int i;

  for(i = nsrc - 1; i >= 0; i--)
  {
    if(src[i] != ' ')
    {
      break;
    }
  }

  return i + 1;
}

// splicer begin class.DataStore.C_definitions
// splicer end class.DataStore.C_definitions

SIDRE_DataStore *SIDRE_DataStore_new(SIDRE_DataStore *SHC_rv)
{
  // splicer begin class.DataStore.method.new
  axom::sidre::DataStore *SHCXX_rv = new axom::sidre::DataStore();
  SHC_rv->addr = static_cast<void *>(SHCXX_rv);
  SHC_rv->idtor = 1;
  return SHC_rv;
  // splicer end class.DataStore.method.new
}

void SIDRE_DataStore_delete(SIDRE_DataStore *self)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.delete
  delete SH_this;
  self->addr = nullptr;
  // splicer end class.DataStore.method.delete
}

SIDRE_Group *SIDRE_DataStore_get_root(SIDRE_DataStore *self, SIDRE_Group *SHC_rv)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.getRoot
  axom::sidre::Group *SHCXX_rv = SH_this->getRoot();
  SHC_rv->addr = SHCXX_rv;
  SHC_rv->idtor = 0;
  return SHC_rv;
  // splicer end class.DataStore.method.getRoot
}

size_t SIDRE_DataStore_get_num_buffers(const SIDRE_DataStore *self)
{
  const axom::sidre::DataStore *SH_this =
    static_cast<const axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.getNumBuffers
  size_t SHC_rv = SH_this->getNumBuffers();
  return SHC_rv;
  // splicer end class.DataStore.method.getNumBuffers
}

SIDRE_Buffer *SIDRE_DataStore_get_buffer(SIDRE_DataStore *self,
                                         SIDRE_IndexType idx,
                                         SIDRE_Buffer *SHC_rv)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.getBuffer
  axom::sidre::Buffer *SHCXX_rv = SH_this->getBuffer(idx);
  // C_error_pattern
  if(SHCXX_rv == nullptr)
  {
    SHC_rv->addr = NULL;
    SHC_rv->idtor = 0;
    return NULL;
  }

  SHC_rv->addr = SHCXX_rv;
  SHC_rv->idtor = 0;
  return SHC_rv;
  // splicer end class.DataStore.method.getBuffer
}

SIDRE_Buffer *SIDRE_DataStore_get_buffer_int32_t(SIDRE_DataStore *self,
                                                 int32_t idx,
                                                 SIDRE_Buffer *SHC_rv)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.getBuffer_int32_t
  axom::sidre::Buffer *SHCXX_rv = SH_this->getBuffer(idx);
  // C_error_pattern
  if(SHCXX_rv == nullptr)
  {
    SHC_rv->addr = NULL;
    SHC_rv->idtor = 0;
    return NULL;
  }

  SHC_rv->addr = SHCXX_rv;
  SHC_rv->idtor = 0;
  return SHC_rv;
  // splicer end class.DataStore.method.getBuffer_int32_t
}

SIDRE_Buffer *SIDRE_DataStore_get_buffer_int64_t(SIDRE_DataStore *self,
                                                 int64_t idx,
                                                 SIDRE_Buffer *SHC_rv)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.getBuffer_int64_t
  axom::sidre::Buffer *SHCXX_rv = SH_this->getBuffer(idx);
  // C_error_pattern
  if(SHCXX_rv == nullptr)
  {
    SHC_rv->addr = NULL;
    SHC_rv->idtor = 0;
    return NULL;
  }

  SHC_rv->addr = SHCXX_rv;
  SHC_rv->idtor = 0;
  return SHC_rv;
  // splicer end class.DataStore.method.getBuffer_int64_t
}

SIDRE_Buffer *SIDRE_DataStore_create_buffer_empty(SIDRE_DataStore *self,
                                                  SIDRE_Buffer *SHC_rv)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.createBuffer_empty
  axom::sidre::Buffer *SHCXX_rv = SH_this->createBuffer();
  SHC_rv->addr = SHCXX_rv;
  SHC_rv->idtor = 0;
  return SHC_rv;
  // splicer end class.DataStore.method.createBuffer_empty
}

SIDRE_Buffer *SIDRE_DataStore_create_buffer_from_type(SIDRE_DataStore *self,
                                                      SIDRE_TypeID type,
                                                      SIDRE_IndexType num_elems,
                                                      SIDRE_Buffer *SHC_rv)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.createBuffer_from_type
  axom::sidre::TypeID SHCXX_type = static_cast<axom::sidre::TypeID>(type);
  axom::sidre::Buffer *SHCXX_rv = SH_this->createBuffer(SHCXX_type, num_elems);
  // C_error_pattern
  if(SHCXX_rv == nullptr)
  {
    SHC_rv->addr = NULL;
    SHC_rv->idtor = 0;
    return NULL;
  }

  SHC_rv->addr = SHCXX_rv;
  SHC_rv->idtor = 0;
  return SHC_rv;
  // splicer end class.DataStore.method.createBuffer_from_type
}

SIDRE_Buffer *SIDRE_DataStore_create_buffer_from_type_int32_t(SIDRE_DataStore *self,
                                                              SIDRE_TypeID type,
                                                              int32_t num_elems,
                                                              SIDRE_Buffer *SHC_rv)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.createBuffer_from_type_int32_t
  axom::sidre::TypeID SHCXX_type = static_cast<axom::sidre::TypeID>(type);
  axom::sidre::Buffer *SHCXX_rv = SH_this->createBuffer(SHCXX_type, num_elems);
  // C_error_pattern
  if(SHCXX_rv == nullptr)
  {
    SHC_rv->addr = NULL;
    SHC_rv->idtor = 0;
    return NULL;
  }

  SHC_rv->addr = SHCXX_rv;
  SHC_rv->idtor = 0;
  return SHC_rv;
  // splicer end class.DataStore.method.createBuffer_from_type_int32_t
}

SIDRE_Buffer *SIDRE_DataStore_create_buffer_from_type_int64_t(SIDRE_DataStore *self,
                                                              SIDRE_TypeID type,
                                                              int64_t num_elems,
                                                              SIDRE_Buffer *SHC_rv)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.createBuffer_from_type_int64_t
  axom::sidre::TypeID SHCXX_type = static_cast<axom::sidre::TypeID>(type);
  axom::sidre::Buffer *SHCXX_rv = SH_this->createBuffer(SHCXX_type, num_elems);
  // C_error_pattern
  if(SHCXX_rv == nullptr)
  {
    SHC_rv->addr = NULL;
    SHC_rv->idtor = 0;
    return NULL;
  }

  SHC_rv->addr = SHCXX_rv;
  SHC_rv->idtor = 0;
  return SHC_rv;
  // splicer end class.DataStore.method.createBuffer_from_type_int64_t
}

void SIDRE_DataStore_destroy_buffer(SIDRE_DataStore *self, SIDRE_IndexType id)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.destroyBuffer
  SH_this->destroyBuffer(id);
  // splicer end class.DataStore.method.destroyBuffer
}

bool SIDRE_DataStore_generate_blueprint_index_0(SIDRE_DataStore *self,
                                                const char *domain_path,
                                                const char *mesh_name,
                                                const char *index_path,
                                                int num_domains)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.generateBlueprintIndex_0
  const std::string SHCXX_domain_path(domain_path);
  const std::string SHCXX_mesh_name(mesh_name);
  const std::string SHCXX_index_path(index_path);
  bool SHC_rv = SH_this->generateBlueprintIndex(SHCXX_domain_path,
                                                SHCXX_mesh_name,
                                                SHCXX_index_path,
                                                num_domains);
  return SHC_rv;
  // splicer end class.DataStore.method.generateBlueprintIndex_0
}

bool SIDRE_DataStore_generate_blueprint_index_0_bufferify(SIDRE_DataStore *self,
                                                          char *domain_path,
                                                          int SHT_domain_path_len,
                                                          char *mesh_name,
                                                          int SHT_mesh_name_len,
                                                          char *index_path,
                                                          int SHT_index_path_len,
                                                          int num_domains)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.generateBlueprintIndex_0_bufferify
  const std::string SHCXX_domain_path(
    domain_path,
    ShroudLenTrim(domain_path, SHT_domain_path_len));
  const std::string SHCXX_mesh_name(mesh_name,
                                    ShroudLenTrim(mesh_name, SHT_mesh_name_len));
  const std::string SHCXX_index_path(
    index_path,
    ShroudLenTrim(index_path, SHT_index_path_len));
  bool SHC_rv = SH_this->generateBlueprintIndex(SHCXX_domain_path,
                                                SHCXX_mesh_name,
                                                SHCXX_index_path,
                                                num_domains);
  return SHC_rv;
  // splicer end class.DataStore.method.generateBlueprintIndex_0_bufferify
}

#ifdef AXOM_USE_MPI
bool SIDRE_DataStore_generate_blueprint_index_1(SIDRE_DataStore *self,
                                                MPI_Fint comm,
                                                const char *domain_path,
                                                const char *mesh_name,
                                                const char *index_path)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.generateBlueprintIndex_1
  MPI_Comm SHCXX_comm = MPI_Comm_f2c(comm);
  const std::string SHCXX_domain_path(domain_path);
  const std::string SHCXX_mesh_name(mesh_name);
  const std::string SHCXX_index_path(index_path);
  bool SHC_rv = SH_this->generateBlueprintIndex(SHCXX_comm,
                                                SHCXX_domain_path,
                                                SHCXX_mesh_name,
                                                SHCXX_index_path);
  return SHC_rv;
  // splicer end class.DataStore.method.generateBlueprintIndex_1
}
#endif  // ifdef AXOM_USE_MPI

#ifdef AXOM_USE_MPI
bool SIDRE_DataStore_generate_blueprint_index_1_bufferify(SIDRE_DataStore *self,
                                                          MPI_Fint comm,
                                                          char *domain_path,
                                                          int SHT_domain_path_len,
                                                          char *mesh_name,
                                                          int SHT_mesh_name_len,
                                                          char *index_path,
                                                          int SHT_index_path_len)
{
  axom::sidre::DataStore *SH_this =
    static_cast<axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.generateBlueprintIndex_1_bufferify
  MPI_Comm SHCXX_comm = MPI_Comm_f2c(comm);
  const std::string SHCXX_domain_path(
    domain_path,
    ShroudLenTrim(domain_path, SHT_domain_path_len));
  const std::string SHCXX_mesh_name(mesh_name,
                                    ShroudLenTrim(mesh_name, SHT_mesh_name_len));
  const std::string SHCXX_index_path(
    index_path,
    ShroudLenTrim(index_path, SHT_index_path_len));
  bool SHC_rv = SH_this->generateBlueprintIndex(SHCXX_comm,
                                                SHCXX_domain_path,
                                                SHCXX_mesh_name,
                                                SHCXX_index_path);
  return SHC_rv;
  // splicer end class.DataStore.method.generateBlueprintIndex_1_bufferify
}
#endif  // ifdef AXOM_USE_MPI

void SIDRE_DataStore_print(const SIDRE_DataStore *self)
{
  const axom::sidre::DataStore *SH_this =
    static_cast<const axom::sidre::DataStore *>(self->addr);
  // splicer begin class.DataStore.method.print
  SH_this->print();
  // splicer end class.DataStore.method.print
}

}  // extern "C"
